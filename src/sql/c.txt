指针是c语言灵魂
指针指向内存地址,内存地址是内存单元的从0开始到4G-1的操作数据线的非负整数的编号,内存内容随便写,内存编号唯一,不能重复
指针就是地址,地址就是指针
指针变量是存放内存的单元地址的变量
指针本质是通过数据线
	cpu与内存,靠三个总线确定,
	地址线(确定地址),
	控制线(读/写),
	数据线(仅数据传输),(0到4G-1)
#include<stdio.h>
int main(void){
	
	int *p;//p是变量名,int*表示变量p只能存储int类型变量的地址
	int i = 10;//i的内存地址中存储的值为10
	int j;//j的地址未知
	//j = *p;//这里 *p地址存储的数据未知,垃圾构造
	
	p=&i;//p指向i:(i的地址发送给p),修改p的值不影响i,修改i的值不影响p,*p等价于i
	//*p中的*表示以变量p的值为内存地址的值
	//反过来说,*表示变量指向(存储)一个变量的值的内存地址
	//总结:如果变量*修饰,那么称作该变量p是个地址编号
	//&i表示变量i的内存地址
	
	
	//int *p = &i;//等价于int *p;p =&i;
	*p = i;//等价于i=i
	j = *p;//等价于j=i
	
	printf("i = %d;j=%d;*p=%d\n",i,j,*p);
	return 0;
}

函数问题:
函数调用时压栈出栈,通过(没有返回值的)被调用函数修改调用者中的局部变量:
	设计被调用函数参数为指针类型,如int *;
	调用者传入其局部变量的地址&i,
	那么在被调用函数中可以直接访问地址操作复制,
	出栈后,被调用函数变量失效,但地址中已经更改数据

#include <stdio.h>
void Show_Array(int *p,int len){
	p[0] = -1;//p[0]等价于*p
	//* (p+2)表示指向地址向后移动两次的位置 (用值的角度理解:就是移动p(地址)中值同样大小字节数) 
	p[2] = -1;//p[2]等价于 * (p+2),也就是说它等价于 * (a+2)等价于a[2]
}
int main(void){
	int a[5] = {1,2,3,4,5};//数组内存中连续的物理地址
	Show_Array(a,5);//a等价于&a[0],&a[0]本身就是int *类型
	printf("%d\n",a[0]);//这里a[0]值变为-1
	return 0;
}
//由此可知访问一个数组任意地址需要知道数组的首地址和数组长度即可

所有指针占4个字节,第一个字节的地址表示整个变量的地址
# include<stdio.h>
int main(void){
	double * p;
	double x = 66.6;
	p = &x;//x占8个字节,1个字节是8bit,1个字节一个地址
	//p只存放一个地址,(首地址或末地址)
	double arr[3] = {1.1,2.2,3.3};
	double *q;
	q = &arr[0];
	printf("%p\n",q);//%p是以16进制输出
	q = &arr[1];
	printf("%p\n",q);
	return 0;
}

# include<stdio.h>
void f(); //声明
int main(void){
	int i = 10;
	f(&i);
	printf("i = %d\n",i};
	return 0;
}
void f(int * p){
	*p = 99;
}










