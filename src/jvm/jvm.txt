虚拟机过程分析:
javac编译java文件为class文件
使用jdk自带的jvisualvm工具bin/jvisualvm.exe软件

class文件:
把Java源码丢给JVM肯定是不能执行的，需要先用javac编译成class文件才行
那么第一个问题：class文件的结构是怎样的？
	参考:
	http://blog.csdn.net/zhengzhb/article/details/7517213
	常量池
	访问标志
	类索引、父类索引和接口索引
	字段表
	方法表
	属性表

虚拟机规范并没有规定在什么时候要加载类，但是规定了在遇到new、反射、父类、Main的时候需要初始化完成。整个类的生命周期如下：

	加载Loading-->连接Linking[验证Verification-->准备Preparation-->解析Resolution]
	-->初始化Initalization-->使用Using-->卸载Unloadinig

	在虚拟机中通过ClassLoader来进行类的加载，这地方需要明白：
		两个类是否相同，除了类名外还需要判断ClassLoader是否相同。
		双亲委派模式并不是一个强制约束。
栈帧
在类加载完成之后就可以开始执行了，和线程运转相关的东西都放在栈帧中，其结构如下：
	局部变量:方法参数及方法内部定义的局部变量
	操作数栈:用来被指令操作
	动态连接:指向运行时常量池中该栈所属方法的引用
	方法返回地址:上层方法调用本方法的位置
	附加信息:调试信息等
		
	执行中具体调用哪个方法是个头疼的问题，需要处理：
		静态分派：相同名称、不同参数类型的方法。
		动态分派：继承中复写的方法。
		
	字节码中的指令都是基于栈的操作，比如要完成1+1这样的计算，对应的指令如下:
	iconst_1 // 将常量1压入栈
	iconst_1
	iadd // 把栈顶的两个值相加并出栈，然后把结果放回栈
	istore_0 // 将栈顶的值放到局部变量表第0个Solt



java xxx-->ClassLoader加载class文件
一个含有main函数的class文件-->读取到常量/静态变量存入方法区Method Area(线程共享)
-->读取到Class.forName()..-->应用对应的ClassLoader加载该class文件,并保存在方法区
-->读取到new XX()-->判断方法区是否含有该类描述信息
-->如果没有仍然通过引用对应的类加载器加载,如果方法区保存的有
-->通过方法区的类信息在Heap空间创建该对象保存
-->当读取到一个对象的方法Method-->在Main Stack栈空间中压栈
	1.将所有的实际参数,返回地址等信息传递给被调函数保存
	2.为被调函数的局部变量(也包括形参)分配存储空间
	3.将控制转移到被掉函数的入口
	对方法压栈,这里一个单元为帧,帧存放的是对象在堆中的内存地址
	如:this.name = name;这里this.name是指向内存当中的一个引用
(类中方法和属性,属性重要,方法运行完就结束了)
-->被加载的方法运行结束后保存返回值,出栈-->
对于OOM:分为堆/栈/方法区溢出,一般都是Heap Overflow
	所以通常调优中一般首先考虑增加堆空间
	



