解决什么是垃圾？
使用引用计数算法和根搜索算法

	1.引用计数算法：被引用次数为0的对象。
	给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；
	当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
		优点是简单，高效，现在的objective-c用的就是这种算法。
		缺点是很难处理循环引用，比如相互引用的两个对象则无法释放。
	
	2.可达性分析算法(根搜索算法)：从GC Roots沿着引用找不到的对象。
	从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，向下搜索它们引用的对象，
	可以生成一棵引用树，树的节点视为可达对象，反之视为不可达。
	这个GC Roots的定义:
		虚拟机栈（帧栈中的本地变量表）中引用的对象。
		方法区中静态属性引用的对象。
		方法区中常量引用的对象。
		本地方法栈中JNI引用的对象。

GC的三大基础算法:
	GC标记/清除算法
	GC的复制算法
	GC的标记/整理算法
--------------------------------------------------------------------
在虚拟机发展的过程中进化出不少垃圾回收算法,
	1.标记-清除算法(Mark-Sweep)
		对象在内存中是构成一颗树，当内存耗尽的时候，程序会停止，然后进行标记和清除;
		标记阶段的任务是标记出所有需要被回收的对象，
		清除阶段就是回收被标记的对象所占用的空间。
		
		优点是简单，容易实现。
		缺点是容易产生内存碎片，碎片太多可能会导致:
			后续过程中需要为大对象分配空间时无法找到足够的空间,而提前触发新的一次垃圾收集动作。
		
	2.复制算法(Copying)
		复制算法将可用内存按容量划分为大小相等的两块,活动区域和空闲区域,每次只使用其中的一块。
		当这一块的内存用完了,就将还存活着的对象标记,并复制到另外一块上面，
		然后再把已使用的内存空间一次清理掉,这样一来就不容易出现内存碎片的问题。
		
		优点:实现简单，运行高效且不容易产生内存碎片;
		缺点:
			对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。
			从算法原理我们可以看出，
			Copying算法的效率跟存活对象的数目多少有很大的关系，
			如果存活对象很多，那么Copying算法的效率将会大大降低。
			
	3.标记-整理算法 (Mark-Compact)
		该算法标记阶段一样，
		然后将存活对象都向一端移动，整理成一块连续的空间区域，然后清理掉端边界以外的内存。
		
		所以，特别适用于存活对象多，回收对象少的情况下。
	其他参考:
	http://blog.csdn.net/baple/article/details/51553953
分代收集算法	
--------------------------------------------------------
目前JVM使用分代收集算法(Hotspot默认)
	分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的的特点综合而成。
	这种综合是考虑到java的语言特性的。这里重复一下两种老算法的适用场景：
		
	    复制算法：适用于存活对象很少。回收对象多
	    标记整理算法: 适用用于存活对象多，回收对象少
	刚好互补！不同类型的对象生命周期决定了更适合采用哪种算法。
	
	于是，我们根据对象存活的生命周期将内存划分为若干个不同的区域。
	新生代追求速度，老年代追求空间，那么就可以根据不同代的特点采取最适合的收集算法。
		新生代每次垃圾回收时都有大量的对象需要被回收，比较适合复制算法;
			新生代有Eden/S1/S2，采用复制算法，速度非常快。Eden中存活的对象会被复制到S2区域。
		老年代每次垃圾收集时只有少量对象需要被回收，一般采用标记/整理(压缩)算法;
			首先标记出老年代中的垃圾对象，然后将存活对象移动到一个连续的区域。
			Full GC将没有用的垃圾对象清除，存活的对象是一块连续的空间。
			垃圾对象也有一个具体的地址，为下一次对象分配的指针，将新对象分配到空闲的位置。
	这就是分代回收算法。

JVM中不同的垃圾回收器
---------------------------------------------------------------
串行的方式在前期JVM流行的GC方式。并行、并发是后来发展出来的。

Serial收集器
	串行收集器是最基本、历史最悠久的收集器,主要有两个特点:
		仅仅使用单线程进行垃圾回收；
		独占式的垃圾回收。
	串行收集器进行垃圾回收时,必须暂停应用程序中其他所有的工作线程(称为”Stop The World”),直到它结束。
	JVM 在 Client 模式下运行时，它是默认的垃圾收集器。
	虽然如此，串行收集器却是一个成熟、经过长时间生产环境考验的极为高效的收集器;
		新生代串行处理器使用复制算法，实现相对简单，逻辑处理特别高效，且没有线程切换的开销。
		在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。
		老年代串行收集器使用的是标记-压缩算法,很可能会因此停顿几秒甚至更长时间
		虽然如此，老年代串行回收器可以和多种新生代回收器配合使用，同时它也可以作为 CMS 回收器的备用回收器。
	-XX：+UseSerialGC 参数可以指定使用新生代串行收集器和老年代串行收集器,
	
并行收集器
并行:在具体GC的时候，有多个线程，提升了吞吐量，坏处在于线程切换是需要时间的。
	它的回收策略、算法以及参数和串行回收器一样。也是独占式的回收器,采用stop the world的方式来进行GC。
		在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，
		而在单 CPU 或者并发能力较弱的系统会由于多线程的压力，实际表现很可能比串行回收器差。
	实际生产环境下，如果资源延迟的要求特别高的情况下，采用ParNew和CMS收集器组合。
	-XX:+UseConcMarkSweepGC 可以要求新生代使用并行收集器，老年代使用CMS。
	-XX:ParallelGCThreads 参数指定并行收集器工作时的线程数量
	
	Parallel可以控制JVM的吞吐量的大小，是吞吐量优先的收集器。其一个重要的特点：它非常关注系统的吞吐量。见参数
	并行回收收集器支持一种自适应的 GC 调节策略
	新生代并行回收收集器其他参数:
	-XX:+UseParNewGC:参数设置新生代使用并行收集器，老年代使用串行收集器。
	-XX:+UseParallelOldGC:新生代和老年代都是用并行回收收集器。
		这是一对非常关注吞吐量的垃圾收集器组合，在对吞吐量敏感的系统中，可以考虑使用
		参数-XX:ParallelGCThreads 也可以用于设置垃圾回收时的线程数量。
	-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间，它的值是一个大于 0 的整数。
		收集器在工作时会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内
	-XX:+GCTimeRatio：设置吞吐量大小，它的值是一个 0-100 之间的整数。
		假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。
	-XX:+UseAdaptiveSizePolicy 可以打开自适应 GC 策略。
		在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，
		以达到在堆大小、吞吐量和停顿时间之间的平衡点。
		在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、
		目标的吞吐量 (GCTimeRatio) 和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。
	
并发标记清除:CMS收集器(Concurrent Mark Sweep)
并发:同一段时间，垃圾回收和具体的工作线程也会同时运行或者交叉运行，缩短了server被stop the world的影响。
	与并行回收收集器不同，CMS 收集器主要关注于系统停顿时间即特点:
		并发收集、低停顿
	-XX:+UseConcMarkSweepGC 可以要求新生代使用并行收集器，老年代使用CMS
	
	CMS工作时，主要步骤有：
		初始标记(CMS initial mark)
		并发标记(CMS concurrent mark)
		重新标记(CMS remark)
		并发清除(CMS concurrent sweep)
		并发重置
		
		其中初始标记和重新标记是独占系统资源的，
		而并发标记、并发清除和并发重置是可以和用户线程一起执行。
		因此，从整体上来说，CMS 收集不是独占式的，它可以在应用程序运行过程中进行垃圾回收。
	
	根据标记-清除算法:
		初始标记、并发标记和重新标记都是为了标记出需要回收的对象;
		并发清理则是在标记完成后，正式回收垃圾对象；
		并发重置是指在垃圾回收完成后，重新初始化 CMS 数据结构和数据，为下一次垃圾回收做好准备。
	
	缺点:	
		由于它和应用程序线程并发执行，相互抢占CPU，所以在CMS执行期内对应用程序吞吐量造成一定影响。
			CMS 默认启动的线程数是 (ParallelGCThreads+3)/4),ParallelGCThreads 是新生代并行收集器的线程数，
			也可以通过-XX:ParallelCMSThreads 参数手工设定 CMS 的线程数量。
		1.CMS收集器对CPU资源非常敏感
			当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。
		2.会产生大量的空间碎片
		3.无法处理浮动垃圾,可能出现Concurrent Mode Failure 失败而导致另一次Full GC的产生
		由于不是独占式的回收器,在应用程序工作过程中，又会不断地产生垃圾,这些新生成的垃圾在当前 CMS 回收过程中是无法清除的。
		同时，因为应用程序没有中断，所以在 CMS 回收过程中，还应该确保应用程序有足够的内存可用。
		因此，CMS 收集器不会等待堆内存饱和时才进行垃圾回收，而是当前堆内存使用率达到某一阈值时，便开始进行回收，
		以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。
			回收阈值可以使用-XX:CMSInitiatingOccupancyFraction 来指定，默认是68
			即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收
	优化:
		如果应用程序的内存使用率增长很快，在 CMS 的执行过程中，已经出现了内存不足的情况，
		此时，CMS 回收将会失败，JVM 将启动老年代串行收集器进行垃圾回收
		如果这样，应用程序将完全中断，直到垃圾收集完成，这时，应用程序的停顿时间可能很长。
		因此，根据应用程序的特点，可以对-XX:CMSInitiatingOccupancyFraction 进行调优。
		如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，
			减少老年代回收的次数可以较为明显地改善应用程序性能。
		反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。
		
		标记-清除算法将会造成大量内存碎片，离散的可用空间无法分配较大的对象。
		在这种情况下，即使堆内存仍然有较大的剩余空间，
		也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存，这种现象对系统性能是相当不利的，
		为了解决这个问题，CMS 收集器还提供了几个用于内存压缩整理的算法。
		-XX:+UseCMSCompactAtFullCollection 参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理,内存碎片的整理并不是并发进行的
		-XX:CMSFullGCsBeforeCompaction 参数可以用于设定进行多少次 CMS 回收后，进行一次内存压缩。
		-XX:CMSInitiatingOccupancyFraction 设置为 100，
		同时设置-XX:+UseCMSCompactAtFullCollection 和-XX:CMSFullGCsBeforeCompaction

G1收集器 (Garbage First)
	G1收集器的目标是作为一款服务器的垃圾收集器，它在吞吐量和停顿控制上，预期要优于CMS收集器,特点:
		紧凑的空闲空间,且没有很长的GC停顿时间
		
		与 CMS 收集器相比，G1 收集器是基于标记-压缩算法的。
			因此，它不会产生空间碎片，也没有必要在收集完成后，进行一次独占式的碎片整理工作。
		G1 收集器还可以进行非常精确的停顿控制。
			它可以让开发人员指定当停顿时长为 M 时，垃圾回收时间不超过 N。
	
	G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收.
	这是由于它能够极力避免全区域的垃圾收集:
		G1启动后不需要请求更大的Java堆,
		而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域(Region),
		并且跟踪这些区域里的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。
			
			这里,每个区域大小相等，在1M~32M之间。
			JVM最多支持2000个区域，可推算G1能支持的最大内存为2000*32M=62.5G。
			区域(region)的大小在JVM初始化的时候决定，也可以用-XX:G1HeapReginSize设置。
			在G1中没有物理上的Yong(Eden/Survivor)/Old Generation，它们是逻辑的，使用一些非连续的区域(Region)组成的。
		新生代收集
			当新生代占用达到一定比例的时候，开始触发收集。
			经过Young GC后存活的对象被复制到一个或者多个区域空闲中，
			这些被填充的区域将是新的新生代，当新生代对象的年龄已经达到阈值，被复制到老年代的区域中。
			回收过程是STW，回收完成后根据Young GC的统计信息调整Eden和Survive的大小，有助于合理利用内存，提高回收效率。
			回收的过程是多个回收线程并发收集。	
		老年代收集
			和CMS类似，G1收集器收集老年代对象会有短暂停顿。
			1、标记阶段，Initial-Mark，这个阶段是STW，并且会触发一次普通Mintor GC。
			2、Root Region Scanning，程序运行过程中会回收survive区（存活到老年代），这一过程在Young GC之前完成。
			3、Concurrent Marking，整个堆中进行并发标记。
			4、Remark再标记，短暂的STW，再标记阶段是用来收集并发标记阶段产生新的垃圾。
			5、Copy/Clean up，多线程清除失活对象，
			会有STW，G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。
		Remember Sets：
			G1收集器中，Region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用是使用Remember Sets来避免扫描全堆。
	
	
	
	
	使用参数
		-XX:+UnlockExperimentalVMOptions –XX:+UseG1GC 来启用 G1 回收器
		-XX:MaxGCPauseMills=20,-XX:GCPauseIntervalMills=200 设置 G1 回收器的目标停顿时间


	主要来自:http://blog.csdn.net/future_ins/article/details/52166294
	其他参考:
	http://www.importnew.com/13827.html
	http://blog.csdn.net/weiyongxuan/article/details/46683823
	http://blog.csdn.net/u012723548/article/details/49966775
	http://www.cnblogs.com/redcreen/archive/2011/05/04/2037029.html




