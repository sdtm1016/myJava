JVM运行时数据区域的三大核心
Heap Area:
	存储的全部都是Object对象实例
		对象实例中一般都包含了其数据成员以及与该对象对应的Class信息
	一个JVM实例在运行的时候只有一个Heap区域,该区域被所有线程共享
Method Area
	方法区域又名静态成员区域,包含整个程序的Class,Static成员等
	方法区被所有的线程共享
Stack Area
	Stack区域属于线程私有,每个线程都会包含一个Statck区域
	Stack区域中含有基本的数据类型以及对象的引用,其他线程均不能直接访问该区域
	分为三大部分:
		基本数据类型区域
		操作指令区域
		上下文等
		
图解JVM内存模型
	JVM内存分布图:
	Java虚拟机在执行的过程中会把它所管理的内存划分为若干个不同的数据区域，大致如下

运行时数据区{
	方法区(Method Area含Constant Pool),虚拟机栈(VM Stack),本地方法栈(Native Method Stack)
	堆(Heap),程序计数器(Program Counter Register)
}
执行引擎JVM Engine-->本地库接口JNI-->本地方法库
(JVM引擎在工作的时候除了操作运行时数据区域以外,还会通过本地方法接口JNI操作C/C++代码)
另外Direct Memory也应提一下,这里不属于JVM范畴,但在数据角度中NIO,OFFHeap等技术都使用了Direct Memory
	
	解析:
		方法区和堆是所有线程共享内存区域,其他为线程特定运行数据区
	
	程序计数器:当前线程执行字节码的行号,如果JVM引擎通过JNI执行本地方法,计数器值为空
	
	虚拟机栈:存放局部变量,操作栈等,
		管理方法执行时候内存模型,一般包含帧
		帧中一般包含方法局部变量,传入参数,动态链接库,返回值信息等
	本地方法栈:与虚拟机栈类似,不过是服务于本地方法
	
	方法区:存放类信息(Class实例),常量,静态变量,JIT编译后的代码等
		一般不会被GC,只有如一个类所有实例对象已经销毁同时对应ClassLoader也已经销毁,才有可能
	
	堆:存放对象(通过方法区的Class信息描述创建)和数组
		基本分为新生代,老年代等,详情参考GC
	
	其他:
	Direct Memory直接内存:通过NIO分配的堆外内存
		NIO也有可能导致内存溢出,机器本省也有限制,如RAM,Swap,Page分页文件,处理器寻址空间大小的限制
	运行时常量池:在方法区,编译时生成的各种字面量和符号使用(字符串常量/符号的引用),
		会在类加载的时候放在运行时常量池中

详情深入学习参考:
	http://blog.csdn.net/vernonzheng/article/details/8458483
		