面试常问问题:
	介绍一下工作中解决过比较有意思的问题。
	HashMap使用中需要注意的点。
		第一个问题主要是想了解一下对方项目经验的含金量，
		第二个问题则是测试下是否知道一些细节，
		比如HashMap是线程不安全的、用HashMap来做缓存的话可能导致内存泄露等
	设计模式:单例.生产者消费者...垃圾回收
-------------------------------------
内存管理
Java虚拟机在执行的过程中会把它所管理的内存划分为若干个不同的数据区域，大致如下

运行时数据区{
	方法区(Method Area),虚拟机栈(VM Stack),本地方法栈(Native Method Stack)
	堆(Heap),程序计数器(Program Counter Register)
}
执行引擎-->本地库接口-->本地方法库

	其中:方法区和堆是所有线程共享内存区域,其他为线程特定运行数据区
各个部分功能如下:
	程序计数器:当前线程执行字节码的行号
	虚拟机栈:存放局部变量,操作栈等
	本地方法栈:与虚拟机栈类似,不过是服务于本地方法
	方法区:存放类信息(Class实例),常量,静态变量,JIT编译后的代码等
	
	堆:存放对象(通过方法区的Class信息描述创建)和数组
	
	运行时常量:编译时生成的各种字面量和符号使用
	直接内存:通过NIO分配的对外内存
	
在内存管理部分比较大的一块内容是GC(垃圾回收)所谓垃圾回收就是将垃圾占用的内存回收掉。

那么第一个问题：什么是垃圾？
	1.引用计数算法：被引用次数为0的对象。
	给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；
	当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
		优点是简单，高效，现在的objective-c用的就是这种算法。
		缺点是很难处理循环引用，比如相互引用的两个对象则无法释放。
	
	2.可达性分析算法(根搜索算法)：从GC Roots沿着引用找不到的对象。
	从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，向下搜索它们引用的对象，
	可以生成一棵引用树，树的节点视为可达对象，反之视为不可达。
	这个GC Roots的定义:
		虚拟机栈（帧栈中的本地变量表）中引用的对象。
		方法区中静态属性引用的对象。
		方法区中常量引用的对象。
		本地方法栈中JNI引用的对象。
这里都提到了引用，在JDK 1.2之后Java就已经对引用的概念 Reference 进行了扩充，
那么第二个问题：有哪些类型的引用？
	1.强引用：Object o = new Object()这种都是强引用。
	2.弱引用：还有用但非必须的，在OOM之前(内存空间将要不足时候)被回收。
	3.软引用：更弱的引用，在下次GC的时候被回收。
	4.虚引用：最弱的，在任何时候都可能被垃圾回收,唯一的作用是在对象被回收的时候可以收到通知。
	参考:
	http://blog.csdn.net/rznice/article/details/45288195
	http://blog.csdn.net/xlll5211314/article/details/45915489
这里只有强引用才能对对象的生命周期造成影响。


在虚拟机发展的过程中进化出不少垃圾回收算法，比如：
	1.标记-清除算法(Mark-Sweep)
		标记-清除算法分为两个阶段：标记阶段和清除阶段。
		标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。
		
		优点是简单，容易实现。
		缺点是容易产生内存碎片，碎片太多可能会导致:
			后续过程中需要为大对象分配空间时无法找到足够的空间,而提前触发新的一次垃圾收集动作。
		
	2.复制算法(Copying)
		复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。
		当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，
		这样一来就不容易出现内存碎片的问题。
		
		优缺点就是，实现简单，运行高效且不容易产生内存碎片，
		但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。
		
		从算法原理我们可以看出，
			Copying算法的效率跟存活对象的数目多少有很大的关系，
			如果存活对象很多，那么Copying算法的效率将会大大降低。
			
	3.标记-整理算法 (Mark-Compact)
		该算法标记阶段和Mark-Sweep一样，
		但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。
		
		所以，特别适用于存活对象多，回收对象少的情况下。
		
	4.分代收集算法(Hotspot默认)
		分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的的特点综合而成。
		这种综合是考虑到java的语言特性的。这里重复一下两种老算法的适用场景：
			
			    复制算法：适用于存活对象很少。回收对象多
			    标记整理算法: 适用用于存活对象多，回收对象少
		刚好互补！不同类型的对象生命周期决定了更适合采用哪种算法。
		于是，我们根据对象存活的生命周期将内存划分为若干个不同的区域。
		一般情况下将堆区划分为老年代（Old Generation）和新生代（Young Generation），
		老年代的特点是每次垃圾收集时只有少量对象需要被回收，
		而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，
		那么就可以根据不同代的特点采取最适合的收集算法。
		这就是分代回收算法。
		
		注:简单阐述内存模型Perm+Old+Eden+[S0+S1]:
			堆内存由垃圾回收器的自动内存管理系统回收。
			堆内存分为两大部分：新生代和老年代。比例为1：2。
			老年代主要存放应用程序中生命周期长的存活对象。
			新生代又分为三个部分：一个Eden区和两个Survivor区，比例为8：1：1。
			Eden区存放新生的对象。
			Survivor存放每次垃圾回收后存活的对象。
			jvm区域总体分两类，heap区和非heap区。
				heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。
				非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。
				
			Eden Space (heap)
			内存最初从这个线程池分配给大部分对象。
			Survivor Space (heap)
			用于保存在eden space内存池中经过垃圾回收后没有被回收的对象。
			Tenured Generation (heap)
			用于保持已经在survivor space内存池中存在了一段时间的对象。
			Permanent Generation (non-heap)
			保存虚拟机自己的静态(reflective)数据，例如类（class）和方法（method）对象。Java虚拟机共享这些类数据。这个区域被分割为只读的和只写的。
			Code Cache (non-heap)
			HotSpot Java虚拟机包括一个用于编译和保存本地代码（native code）的内存，叫做“代码缓存区”（code cache）。
		 
		整体上来看是分代收集算法，而S0、S1这两部分可以看做是标记-整理算法。
	
	深入理解分代收集算法:
	1.为什么不是一块Survivor空间而是两块？
		这里涉及到一个新生代和老年代的存活周期的问题，
		比如一个对象在新生代经历15次（仅供参考）GC，就可以移到老年代了。
		那么每次GC时，要把存活对象Survivor B与Survivor A空间，反复copy。
		所以，这里就需要两块Survivor空间来回倒腾。	
	2.为什么Eden空间这么大而Survivor空间要分的少一点？
		新创建的对象都是放在Eden空间，这是很频繁的，尤其是大量的局部变量产生的临时对象，
		这些对象绝大部分都应该马上被回收，能存活下来被转移到survivor空间的往往不多。
		所以，设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了Copying算法的缺点。
		当然8：1：1这个比例是可以调整的，包括上面的新生代和老年代的1：2的比例也是可以调整的。
		从Eden空间往Survivor空间转移的时候Survivor空间不够了会直接放到老年代去。
	3.Eden空间和两块Survivor空间的工作流程
		假定有新生代Eden，Survivor A， Survivor B三块空间和老生代Old一块空间。

		1.不断分配对象-->放到Eden区-->Eden区满-->新生代GC：Minor GC:
			 把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的）
		继续重复1-->把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区
		如此循环则会出现下面各种情况:
			有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区
			有的对象太大，超过了Eden区，直接被分配在Old区
			有的存活对象，放不下Survivor区，也被分配到Old区
		2.然后,在某次Minor GC的过程中突然发现->老年代Old区满
		-->进行大GC:老年代GC：Major GC-->Old区慢慢的整理一番，空间又够了
		
	触发GC的类型		
	了解这些是为了解决实际问题，Java虚拟机会把每次触发GC的信息打印出来来帮助我们分析问题，所以掌握触发GC的类型是分析日志的基础。
	    GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。
	    GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。
	    GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。
	    GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。
		了解Java虚拟机GC原理，应该对于Dalvik虚拟机和Art虚拟机的GC原理有很大帮助，至于这三者的GC有什么区别，只能一步一步来了。

	参考:
	http://blog.csdn.net/baple/article/details/51553953
	http://www.importnew.com/15802.html
	http://blog.csdn.net/future_ins/article/details/52166294
	http://www.cnblogs.com/zhguang/p/3257367.html

那么第三个问题：常见的CMS垃圾回收器的执行流程是怎样的？
http://blog.csdn.net/u012723548/article/details/49966775
	1.初始标记：GC Roots直接关联的对象。
	2.并发标记：Root Tracing。
	3.重新标记：修复由于程序运行导致标记产生变动。
	4.并发清除
CPU0,1..--用户线程1,2..-->所有线程停止进行初始标记-->单个线程停止并发标记
-->所有线程停止重新标记-->单个线程停止进行并发请求-->单个线程停止进行重置线程
可以看到只有在初始标记和重新标记的时候才需要Stop The World，
其他都是和用户线程一起执行，不要以为这就完美了，并行执行的过程会消耗掉一些CPU资源




代码执行
-----------------------------------------------


JIT:
	解释执行的好处是下载后启动速度快，但是确定也非常明显：运行速度慢。
	JIT正是用来解决这个问题的，能够将多次调用的方法、多次执行的循环体编译成本地代码。
	在JIT中比较常见的优化手段有：
		公共子表达式消除:如果一个表达式已经计算过了,那么后面不需要重复计算
		数组范围检查消除:并不是必须一次不漏地检查
		方法内联:把代码复制到调用方法中
		逃逸分析:判断对象是否可能被方法外引用到

内存操作
程序执行一定会涉及到内存操作，在Java中定义了八种操作来完成：
	lock:把一个变量表示为线程独占状态
	unlock:释放变量
	read:将变量从主存读取到工作内存
	load:将read到的变量值放入工作内存中的副本
	use:将工作内存中的变量传递给执行引擎
	assign:引擎返回的值传递给工作内存中的副本
	store:将工作内存中的变量传递给主内存
	write:把工作内存得到的变量写入主内存队形的变量中

这里有必要讲一下volatile的作用，在使用到的时候能明白下面两条即可：
	保证变量对所有线程是可见的。
	禁止指令重排优化。
如果Java中所有的操作都需要程序员来控制的话，会有大量的重复代码，而且写起来很累，
那么我们可以通过先行发生原则来判断并行的两个操作是否存在冲突：
	程序次序规则：单线程内按照程序书写顺序。
	管程锁定规则：unlock必须在lock之前。
	volatile变量规则：写操作先行发生于读操作。
	线程启动规则：Thread.start()先于线程的其他任意方法。
	线程终止规则：线程中所有的操作都先于对此线程的终止检测。
	线程中断规则：interrupt()先于中断检测。
	对象终结规则：对象的初始化完成先于它的finalize()方法。
	传递规则：如果A先于B、B先于C，那么A先于C。
Thread的底层实现还是比较麻烦的，但是最起码应该知道Thread的状态是如何进行转换：
New--start-->Running,synchroized--Blocked
wait/notify/notifyall--Waiting
sleep---Timed Waiting
run结束--Terminated


其他:
http://blog.csdn.net/baple/article/details/51553953

